from enum import Enum 
import io,ast,os
import re
# from shutil import which


file_header = "// WARNING: This File was generated by omegaslc. DO NOT EDIT!\n\n"

"""

Standard Resource Types:

ConstBuffer[T,I]
Buffer[T,I]
Texture2D[T,I]
Texture3D[T,I]
Texture1D[T,I]

Std Data Types:

float
float2
float3
float4

float1x2
float2x2
float3x2
float4x2

float1x3
float2x3
float3x3
float4x3

float1x4
float2x4
float3x4
float4x4


"""

def is_standard_type(ty:str) -> bool:
    return ty == "float" or ty == "float2" or ty == "float3" or ty == "float4"

def utf8str_to_bytes(s:str) -> bytes:
    return bytes(s,"utf8")

def int_to_bn_uint(n:int) -> bytes:
    return n.to_bytes(4,byteorder="little",signed=False)

class TargetType(Enum):
    HLSL = 0,
    METAL = 1,
    GLSL = 2

class ShaderType(Enum):
    VERTEX = 0,
    FRAGMENT = 1,
    COMPUTE = 2

r = re.compile(r'(?:\/|\.|-)',re.MULTILINE | re.DOTALL)

def clean_name(subject:str) -> str:
    return r.sub('_',subject)


class TargetOutputContext(object):
    source_file:str
    temp_dir:str
    output_dir:str
    b:"dict[str,list[bytes]]"
    def __init__(self):
        self.b = {}
        return
    out:io.TextIOWrapper
    shaderMapOut:io.BufferedWriter

    def write(self,content:str):
        self.out.write(content)
    
    def writeShaderMap(self):
       l = len(self.b)
       self.shaderMapOut.write(int_to_bn_uint(l))
       for e in self.b:
           self.shaderMapOut.write(int_to_bn_uint(len(e)))
           self.shaderMapOut.write(utf8str_to_bytes(e))
           self.shaderMapOut.write(int_to_bn_uint(len(self.b[e])))
           for shaderName in self.b[e]:
               self.shaderMapOut.write(int_to_bn_uint(len(shaderName)))
               self.shaderMapOut.write(shaderName)
    def writeShaderEntryToMap(self,filename:str,data:bytes):
        if self.b.get(filename) is None:
            self.b[filename] = []
        self.b[filename].append(data)
    
    def writeEBinConfig(self,ebin:io.TextIOWrapper):
        """
        Writes .ebin file
        """
        for e in self.b:
            ebin.write(clean_name(e))
            ebin.write("=")
            ebin.write(e)
    def writeShaderLibEmbeddedBridge(self,lib_name:str,src:io.TextIOWrapper,header:io.TextIOWrapper):
        r"""
        Writes to lib_name.omegasl.c and a lib_name.omegasl.h
        """
        src.write(f'// Warning. This file was created by omegaslc. DO NOT EDIT!\n#include"{lib_name}.omegasl.h"\n')
        for e in self.b:
            src.write(f"extern const char {clean_name(e)}[];\n")
        header.write(f'// Warning. This file was created by omegaslc. DO NOT EDIT!\n#include "omegasl.h"\n#include <string>\n#include <unordered_map>\nvoid {lib_name}_omegasl_load(std::unordered_map<std::string,omegasl_lib_entry> & out);')
        src.write(f"void {lib_name}_omegasl_load(std::unordered_map<std::string,omegasl_lib_entry> & out)")
        src.write("{\n")
        for e in self.b:
            src.write(f'out.insert(std::make_pair("{clean_name(e)}",\n')
            src.write("{")
            src.write(f'"{clean_name(e)}",')
            src.write(clean_name(e) + ",")
            src.write("{")
            
            for s in self.b[e]:
                src.write(f'"{s.decode("utf-8")}"')
                src.write(",")
            src.write("},")
            src.write(str(len(self.b[e])))
            src.write("}")
            src.write("));\n")
        src.write("}")
   

class Target(object):
    """
    The interface for all Targets
    """
    out:TargetOutputContext
    type:TargetType

    def __init__(self,out:TargetOutputContext,type:TargetType):
        self.out = out
        self.type = type

    def writeIdentifier(self,name:str):
        self.out.write(name)
        pass
    
    def writeType(self,name:str):
        self.out.write(name)
        return
    def writeOperator(self,op:ast.operator):
        if isinstance(op,ast.Add):
            self.out.write(" + ")
        elif isinstance(op,ast.Sub):
            self.out.write(" - ")
        elif isinstance(op,ast.Mult):
            self.out.write(" * ")
        elif isinstance(op,ast.Div):
            self.out.write(" / ")
        pass 

    def writeLogicOperator(self,op:ast.boolop):
        if isinstance(op,ast.And):
            self.out.write(" && ")
        elif isinstance(op,ast.Or):
            self.out.write(" || ")
        elif isinstance(op,ast.Not):
            self.out.write(" ! ")
        
    def convertTypeIfStandard(type:str):
        pass
    def writeStructDecl(self,name:str):
        self.out.write(f"struct {name}")
        return
    def annotationToString(self,n:ast.AnnAssign) -> str:
        pass
    def writeStructPropDecl(self,name:str,type:str):
        pass
    def writeVertexShaderDecl(self,name:str,type_str:str,params:"dict[str,str]"):
        pass
    def writeVertexShaderReturn(self):
        self.out.write("return ")
        pass
    def writeFragmentShaderDecl(self,name:str,type_str:str,params:"dict[str,str]"):
        pass
    def writeFragmentShaderReturn(self):
        self.out.write("return ")
        pass
    def writeComputeShaderDecl(self,name:str,type_str:str,params:"dict[str,str]"):
        pass
    def writeComputeShaderReturn(self,name:str,type_str:str,params:"dict[str,str]"):
        self.out.write("return ")
        pass
    def beginBlock(self):
        pass
    def endBlock(self):
        pass
    def finish(self):
        pass
    


