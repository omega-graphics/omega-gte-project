#include "CodeGen.h"

namespace omegasl {

    const char defaultHeaders[] = R"(// Warning! This file was generated by omegaslc
#include <metal_stdlib>
#include <simd/simd.h>

)";

    class MetalCodeGen : public CodeGen {
        std::ofstream shaderOut;

        std::map<std::string,std::string> generatedResources;
        std::map<std::string,std::string> generatedFuncs;
    public:
        MetalCodeGen(CodeGenOpts &opts): CodeGen(opts){

        }
        inline void writeTypeExpr(ast::TypeExpr *t,std::ostream & out){
            using namespace ast;
            auto * _t = typeResolver->resolveTypeWithExpr(t);

            if(_t == builtins::void_type){
                out << "void";
            }
            else if(_t == builtins::int_type){
                out << "int";
            }
            else if(_t == builtins::float_type){
                out << "float";
            }


            if(t->pointer){
                out << " *";
            }
        }
        void writeExpr(ast::Expr *expr,std::ostream & out){

        }
        void generateExpr(ast::Expr *expr) override {
            writeExpr(expr,shaderOut);
        }
        void generateDecl(ast::Decl *decl) override {
            switch (decl->type) {
                case RESOURCE_DECL : {
                    auto *_decl = (ast::ResourceDecl *)decl;
                    std::ostringstream out;
                    writeTypeExpr(_decl->typeExpr,out);
                    out << _decl->name;
                    generatedResources.insert(std::make_pair(_decl->name,out.str()));
                    break;
                }
                case SHADER_DECL : {
                    auto *_decl = (ast::ShaderDecl *)decl;
                    shaderOut.open(OmegaCommon::String(opts.tempDir) + "/" + _decl->name + ".metal");
                    shaderOut << defaultHeaders;

                    if(_decl->shaderType == ast::ShaderDecl::Vertex){
                        shaderOut << "vertex";
                    }
                    else if(_decl->shaderType == ast::ShaderDecl::Fragment){
                        shaderOut << "fragment";
                    }
                    else if(_decl->shaderType == ast::ShaderDecl::Compute){
                        shaderOut << "kernel";
                    }

                    shaderOut << " ";
                    writeTypeExpr(_decl->returnType,shaderOut);
                    shaderOut << " " << _decl->name << " ";
                    shaderOut << "(";





                    shaderOut.close();
                    break;
                }
                default : {
                    break;
                }
            }
        }
        void writeNativeStructDecl(ast::StructDecl *decl, std::ostream &out) override {
            out << "struct " << decl->name << "_ {" << std::endl;
            for(auto p : decl->fields){
                out << "    " << std::flush;
                writeTypeExpr(p->typeExpr,out);
                out << " " << p->spec.name << " " << std::flush;
                if(p->spec.initializer.has_value()){
                    out << "= " << std::flush;
                    writeExpr(p->spec.initializer.value(),out);
                }
                out << ";" << std::endl;
            }
            out << "};" << std::endl;
        }
        void compileShader(ast::ShaderDecl::Type type, const OmegaCommon::StrRef &name, const OmegaCommon::FS::Path &path,const OmegaCommon::FS::Path & outputPath) override {
            std::ostringstream out("xcrun metal ");
            out << "-o " << OmegaCommon::FS::Path(outputPath).append(name).str() << ".air " << "-c " << OmegaCommon::FS::Path(path).str();
            std::system(out.str().c_str());
            out.str("xcrun metallib");
            out << "-o " << OmegaCommon::FS::Path(outputPath).append(name).str() << ".metallib " << OmegaCommon::FS::Path(path).str();
            std::system(out.str().c_str());
        }
    };

    std::shared_ptr<CodeGen> MetalCodeGenMake(CodeGenOpts &opts){
        return std::make_shared<MetalCodeGen>(opts);
    };
}